
from typing import Dict
from typing import List
from typing import NewType

from unittest import TestSuite
from unittest import main as unitTestMain

from os import linesep as osLineSep

from re import search as regExSearch
from re import Match as regExMatch

from antlr4 import FileStream
from antlr4 import CommonTokenStream
from antlr4.error.ErrorListener import ConsoleErrorListener

from codeallybasic.UnitTestBase import UnitTestBase

from pyutmodelv2.PyutType import PyutType
from pyutmodelv2.PyutClass import PyutClass
from pyutmodelv2.PyutField import PyutField
from pyutmodelv2.PyutField import PyutFields
from pyutmodelv2.PyutMethod import PyutMethod
from pyutmodelv2.PyutMethod import PyutMethods
from pyutmodelv2.enumerations.PyutVisibility import PyutVisibility

from tests.umlextensions.input.python.visitor.BaseTestPythonPegVisitor import PyutFieldHashIndex

from umlextensions.input.python.visitor.ParserTypes import Associations
from umlextensions.input.python.visitor.ParserTypes import ParentName
from umlextensions.input.python.visitor.ParserTypes import PyutClasses
from umlextensions.input.python.visitor.ParserTypes import PyutClassName
from umlextensions.input.python.visitor.PythonPegParserVisitor import METHOD_FIND_PATTERN
from umlextensions.input.python.visitor.PythonPegParserVisitor import PythonPegParserVisitor
from umlextensions.input.python.visitor.PythonPegParserClassVisitor import PythonPegParserClassVisitor

from umlextensions.input.python.pythonpegparser.PythonLexer import PythonLexer
from umlextensions.input.python.pythonpegparser.PythonParser import PythonParser

from tests.umlextensions.input.python.visitor.BaseTestPythonPegVisitor import BaseTestPythonPegVisitor

SIMPLE_DATA_CLASS_NAME: PyutClassName = PyutClassName('SimpleDataClass')

PyutMethodHashIndex = NewType('PyutMethodHashIndex', Dict[str, PyutMethod])

class PythonErrorListener(ConsoleErrorListener):
    pass


class TestPythonPegParserVisitor(BaseTestPythonPegVisitor):
    """
    Auto generated by the one and only:
        Gato Malo â€“ Humberto A. Sanchez II
        Generated: 27 October 2025
    """

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

    def setUp(self):
        super().setUp()

    def tearDown(self):
        super().tearDown()

    def testMultiClassFileWithInheritance(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('Opie.py')
        visitor: PythonPegParserVisitor         = PythonPegParserVisitor()

        visitor.pyutClasses = self._do1stPassPegBasedParser('Opie.py')
        visitor.visit(tree)

        expectedParentName: str = 'Cat'
        expectedChildName:  str = 'Opie'

        self.assertTrue(expectedParentName in visitor.parents, 'Missing parent')

        actualChildName: str = visitor.parents[ParentName(expectedParentName)][0]

        self.assertEqual(expectedChildName, actualChildName, 'Missing child')

    def testMultipleInheritanceClass(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('MultipleInheritance.py')
        visitor: PythonPegParserVisitor         = PythonPegParserVisitor()

        visitor.pyutClasses = self._do1stPassPegBasedParser('MultipleInheritance.py')
        visitor.visit(tree)

        self.logger.info(f'{visitor.parents=}')

        expectedParentName1: str = 'Car'
        expectedParentName2: str = 'Flyable'

        self.assertTrue(expectedParentName1 in visitor.parents, f'Missing parent: {expectedParentName1}')
        self.assertTrue(expectedParentName2 in visitor.parents, f'Missing parent: {expectedParentName2}')

    def testMultipleInheritanceWithMetaClass(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('MultipleInheritanceWithMetaClass.py')
        visitor: PythonPegParserVisitor         = PythonPegParserVisitor()

        visitor.pyutClasses = self._do1stPassPegBasedParser('MultipleInheritanceWithMetaClass.py')
        visitor.visit(tree)

        expectedParentName1: str = 'BaseWxCommand'
        expectedParentName2: str = 'MyMetaBaseWxCommand'

        self.assertTrue(expectedParentName1 in visitor.parents, f'Missing parent: {expectedParentName1}')
        self.assertTrue(expectedParentName2 in visitor.parents, f'Missing parent: {expectedParentName2}')

    def testClassMethods(self):

        visitor: PythonPegParserVisitor = self._setupSimpleClassVisitor()

        className:   PyutClassName = PyutClassName('SimpleClass')
        pyutClasses: PyutClasses = visitor.pyutClasses

        pyutClass:   PyutClass   = pyutClasses[className]
        pyutMethods: PyutMethods = pyutClass.methods

        methodNames: List[str] = []

        for method in pyutMethods:
            methodNames.append(method.name)

        self.assertIn('simpleMethod', methodNames, 'Missing known method')
        self.assertIn('methodWithParametersAndDefaultValues', methodNames, 'Missing known method')

    def testCorrectMethodCount(self):

        visitor: PythonPegParserVisitor = self._setupSimpleClassVisitor()

        className:   PyutClassName = PyutClassName('SimpleClass')
        pyutClasses: PyutClasses = visitor.pyutClasses

        pyutClass:   PyutClass   = pyutClasses[className]
        pyutMethods: PyutMethods = pyutClass.methods

        self.assertEqual(10, len(pyutMethods), 'Mismatch in number of methods parsed')

    def testProtectedMethodVisibility(self):
        self._runVisibilityTest('_protectedMethod', PyutVisibility.PROTECTED)

    def testPrivateMethodVisibility(self):
        self._runVisibilityTest('__privateMethod', PyutVisibility.PRIVATE)

    def testDunderMethodVisibility(self):
        self._runVisibilityTest('__str__', PyutVisibility.PUBLIC)

    def testMethodFindRegEx(self):

        defString: str = (
            f'def __init__(self):{osLineSep}'
            f'    self._age:           int   = 3{osLineSep}'
            f'    self._publicEars:    float = 2{osLineSep}'
            f'    self._protectedTail: bool  = True{osLineSep}'
        )

        match: regExMatch | None = regExSearch(METHOD_FIND_PATTERN, defString)

        self.assertIsNotNone(match, 'We should find this')
        self.logger.debug(f'{match}')

    def testDecoratedMethodFindRegEx(self):
        defString: str = (
            '@abstractmethod'
            'def GetDiagram(self):'
            '   pass'
        )

        match: regExMatch | None = regExSearch(METHOD_FIND_PATTERN, defString)

        self.assertIsNotNone(match, 'We should find this')
        self.logger.debug(f'{match}')

    def testClassWithProperties(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('ClassWithProperties.py')
        visitor: PythonPegParserVisitor = PythonPegParserVisitor()

        visitor.pyutClasses = self._do1stPassPegBasedParser('ClassWithProperties.py')
        visitor.visit(tree)

        className: PyutClassName = PyutClassName('ClassWithProperties')
        pyutClass: PyutClass = visitor.pyutClasses[className]

        self.assertEqual(2, len(pyutClass.fields), 'Not enough properties converted to fields')

    def testAssociationsGenerated(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('AssociationClasses.py')
        visitor: PythonPegParserVisitor = PythonPegParserVisitor()

        visitor.pyutClasses = self._do1stPassPegBasedParser('AssociationClasses.py')

        visitor.visit(tree)

        associations: Associations = visitor.associations

        self.assertEqual(2, len(associations), 'Incorrect number of associations generated')

    def testSimpleDataClass(self):

        fields: PyutFields = self._getSimpleDataClassFields()

        self.assertEqual(4, len(fields), 'Did not parse expected number of fields for this class')

    def testFullField(self):

        fields: PyutFields         = self._getSimpleDataClassFields()
        index:  PyutFieldHashIndex = self._makeFieldIndex(pyutFields=fields)

        fullField: PyutField = index['y']

        self.assertIsNotNone(fullField, 'Where did it go?')
        self.assertEqual(PyutType('float'), fullField.type, 'Incorrect type')
        self.assertEqual('42.0', fullField.defaultValue, 'Incorrect default value')

    def testNoTypeField(self):
        fields: PyutFields         = self._getSimpleDataClassFields()
        index:  PyutFieldHashIndex = self._makeFieldIndex(pyutFields=fields)

        noAssignmentField: PyutField = index['w']

        self.assertIsNotNone(noAssignmentField, 'Where did it go?')
        self.assertEqual(PyutType(''), noAssignmentField.type, 'Incorrect type')
        self.assertEqual('"A string"', noAssignmentField.defaultValue, 'Incorrect default value')

    def testNoDefaultValueField(self):
        fields: PyutFields         = self._getSimpleDataClassFields()
        index:  PyutFieldHashIndex = self._makeFieldIndex(pyutFields=fields)

        noAssignmentField: PyutField = index['z']

        self.assertIsNotNone(noAssignmentField, 'Where did it go?')
        self.assertEqual(PyutType('int'), noAssignmentField.type, 'Incorrect type')
        self.assertEqual('', noAssignmentField.defaultValue, 'Should not have a value')

    def testExtractMethodCode(self):
        """
        This version of the parser returns the blank lines at the end of
        the methods
        """

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('SimpleClassWithCode.py')
        visitor: PythonPegParserVisitor = PythonPegParserVisitor()

        visitor.pyutClasses = self._do1stPassPegBasedParser('SimpleClassWithCode.py')

        visitor.visit(tree)

        className:   PyutClassName = PyutClassName('SimpleClassWithCode')

        pyutClasses: PyutClasses = visitor.pyutClasses

        pyutClass:   PyutClass   = pyutClasses[className]
        pyutMethods: PyutMethods = pyutClass.methods

        pyutMethodInit: PyutMethod = pyutMethods[0]
        self.assertEqual(7, len(pyutMethodInit.sourceCode), 'Mismatch of source code on __init__')

        pyutMethodPublicMethod: PyutMethod = pyutMethods[1]

        self.assertEqual(7, len(pyutMethodPublicMethod.sourceCode), 'Mismatch of source code on publicMethod')

    def _runVisibilityTest(self, methodName, visibility: PyutVisibility):

        visitor: PythonPegParserVisitor = self._setupSimpleClassVisitor()

        className:   PyutClassName  = PyutClassName('SimpleClass')
        pyutClasses: PyutClasses = visitor.pyutClasses

        pyutClass:   PyutClass   = pyutClasses[className]

        methodDict: PyutMethodHashIndex = self._buildMethodHashIndex(pyutMethods=pyutClass.methods)
        testMethod: PyutMethod          = methodDict[methodName]

        self.assertEqual(visibility, testMethod.visibility, 'Method visibility is incorrect')

    def _buildMethodHashIndex(self, pyutMethods: PyutMethods) -> PyutMethodHashIndex:

        methodDict: PyutMethodHashIndex = PyutMethodHashIndex({})
        for method in pyutMethods:
            methodDict[method.name] = method

        return methodDict

    def _getSimpleDataClassFields(self) -> PyutFields:

        visitor:     PythonPegParserVisitor = self._setupSimpleDataClassVisitor()
        pyutClasses: PyutClasses            = visitor.pyutClasses
        pyutClass:   PyutClass              = pyutClasses[SIMPLE_DATA_CLASS_NAME]

        return pyutClass.fields

    def _setupSimpleClassVisitor(self) -> PythonPegParserVisitor:

        pyutClasses: PyutClasses = self._do1stPassPegBasedParser('SimpleClass.py')

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('SimpleClass.py')
        visitor: PythonPegParserVisitor           = PythonPegParserVisitor()

        visitor.pyutClasses = pyutClasses

        visitor.visit(tree)

        return visitor

    def _setupSimpleDataClassVisitor(self) -> PythonPegParserVisitor:

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('SimpleDataClass.py')
        visitor: PythonPegParserVisitor         = PythonPegParserVisitor()

        visitor.pyutClasses = self._do1stPassPegBasedParser('SimpleDataClass.py')

        visitor.visit(tree)

        return visitor

    def _setupPegBasedParser(self, fileName: str) -> PythonParser.File_inputContext:

        fqFileName: str = UnitTestBase.getFullyQualifiedResourceFileName(BaseTestPythonPegVisitor.RESOURCES_TEST_CLASSES_PACKAGE_NAME, fileName)

        fileStream: FileStream  = FileStream(fqFileName)
        lexer:      PythonLexer = PythonLexer(fileStream)

        stream: CommonTokenStream = CommonTokenStream(lexer)
        parser: PythonParser      = PythonParser(stream)

        parser.removeParseListeners()
        parser.addErrorListener(PythonErrorListener())

        tree: PythonParser.File_inputContext = parser.file_input()
        if parser.getNumberOfSyntaxErrors() != 0:
            self.logger.error(f'File contains {parser.getNumberOfSyntaxErrors()} syntax errors')
            self.assertTrue(False, f'File contains {parser.getNumberOfSyntaxErrors()} syntax errors')

        return tree

    def _do1stPassPegBasedParser(self, fileName: str) -> PyutClasses:

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser(fileName=fileName)
        visitor: PythonPegParserClassVisitor    = PythonPegParserClassVisitor()

        visitor.visit(tree)

        return visitor.pyutClasses


def suite() -> TestSuite:
    import unittest

    testSuite: TestSuite = TestSuite()

    testSuite.addTest(unittest.defaultTestLoader.loadTestsFromTestCase(testCaseClass=TestPythonPegParserVisitor))

    return testSuite


if __name__ == '__main__':
    unitTestMain()
