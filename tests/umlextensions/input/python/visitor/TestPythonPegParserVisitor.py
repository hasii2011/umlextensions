
from typing import Dict
from typing import List
from typing import NewType

from unittest import TestSuite
from unittest import main as unitTestMain

from os import linesep as osLineSep

from re import search as regExSearch
from re import Match as regExMatch

from antlr4 import FileStream
from antlr4 import CommonTokenStream
from antlr4.error.ErrorListener import ConsoleErrorListener

from codeallybasic.UnitTestBase import UnitTestBase
from umlmodel.Class import Class
from umlmodel.Field import Field
from umlmodel.Field import Fields
from umlmodel.FieldType import FieldType
from umlmodel.Method import Method
from umlmodel.Method import Methods
from umlmodel.enumerations.Visibility import Visibility

from tests.umlextensions.input.python.visitor.BaseTestPythonPegVisitor import ModelFieldHashIndex

from umlextensions.input.python.visitor.ParserTypes import Associations
from umlextensions.input.python.visitor.ParserTypes import ParentName
from umlextensions.input.python.visitor.ParserTypes import ModelClasses
from umlextensions.input.python.visitor.ParserTypes import ModelClassName

from umlextensions.input.python.visitor.PythonPegParserVisitor import METHOD_FIND_PATTERN
from umlextensions.input.python.visitor.PythonPegParserVisitor import PythonPegParserVisitor
from umlextensions.input.python.visitor.PythonPegParserClassVisitor import PythonPegParserClassVisitor

from umlextensions.input.python.pythonpegparser.PythonLexer import PythonLexer
from umlextensions.input.python.pythonpegparser.PythonParser import PythonParser

from tests.umlextensions.input.python.visitor.BaseTestPythonPegVisitor import BaseTestPythonPegVisitor

SIMPLE_DATA_CLASS_NAME: ModelClassName = ModelClassName('SimpleDataClass')

MethodHashIndex = NewType('MethodHashIndex', Dict[str, Method])

class PythonErrorListener(ConsoleErrorListener):
    pass


class TestPythonPegParserVisitor(BaseTestPythonPegVisitor):
    """
    Auto generated by the one and only:
        Gato Malo â€“ Humberto A. Sanchez II
        Generated: 27 October 2025
    """

    @classmethod
    def setUpClass(cls):
        super().setUpClass()

    def setUp(self):
        super().setUp()

    def tearDown(self):
        super().tearDown()

    def testMultiClassFileWithInheritance(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('Opie.py')
        visitor: PythonPegParserVisitor         = PythonPegParserVisitor()

        visitor.modelClasses = self._do1stPassPegBasedParser('Opie.py')
        visitor.visit(tree)

        expectedParentName: str = 'Cat'
        expectedChildName:  str = 'Opie'

        self.assertTrue(expectedParentName in visitor.parents, 'Missing parent')

        actualChildName: str = visitor.parents[ParentName(expectedParentName)][0]

        self.assertEqual(expectedChildName, actualChildName, 'Missing child')

    def testMultipleInheritanceClass(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('MultipleInheritance.py')
        visitor: PythonPegParserVisitor         = PythonPegParserVisitor()

        visitor.modelClasses = self._do1stPassPegBasedParser('MultipleInheritance.py')
        visitor.visit(tree)

        self.logger.info(f'{visitor.parents=}')

        expectedParentName1: str = 'Car'
        expectedParentName2: str = 'Flyable'

        self.assertTrue(expectedParentName1 in visitor.parents, f'Missing parent: {expectedParentName1}')
        self.assertTrue(expectedParentName2 in visitor.parents, f'Missing parent: {expectedParentName2}')

    def testMultipleInheritanceWithMetaClass(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('MultipleInheritanceWithMetaClass.py')
        visitor: PythonPegParserVisitor         = PythonPegParserVisitor()

        visitor.modelClasses = self._do1stPassPegBasedParser('MultipleInheritanceWithMetaClass.py')
        visitor.visit(tree)

        expectedParentName1: str = 'BaseWxCommand'
        expectedParentName2: str = 'MyMetaBaseWxCommand'

        self.assertTrue(expectedParentName1 in visitor.parents, f'Missing parent: {expectedParentName1}')
        self.assertTrue(expectedParentName2 in visitor.parents, f'Missing parent: {expectedParentName2}')

    def testClassMethods(self):

        visitor: PythonPegParserVisitor = self._setupSimpleClassVisitor()

        className:   ModelClassName = ModelClassName('SimpleClass')
        modelClasses: ModelClasses = visitor.modelClasses

        modelClass: Class   = modelClasses[className]
        methods:    Methods = modelClass.methods

        methodNames: List[str] = []

        for method in methods:
            methodNames.append(method.name)

        self.assertIn('simpleMethod', methodNames, 'Missing known method')
        self.assertIn('methodWithParametersAndDefaultValues', methodNames, 'Missing known method')

    def testCorrectMethodCount(self):

        visitor: PythonPegParserVisitor = self._setupSimpleClassVisitor()

        className:    ModelClassName = ModelClassName('SimpleClass')
        modelClasses: ModelClasses   = visitor.modelClasses

        modelClass: Class   = modelClasses[className]
        methods:    Methods = modelClass.methods

        self.assertEqual(10, len(methods), 'Mismatch in number of methods parsed')

    def testProtectedMethodVisibility(self):
        self._runVisibilityTest('_protectedMethod', Visibility.PROTECTED)

    def testPrivateMethodVisibility(self):
        self._runVisibilityTest('__privateMethod', Visibility.PRIVATE)

    def testDunderMethodVisibility(self):
        self._runVisibilityTest('__str__', Visibility.PUBLIC)

    def testMethodFindRegEx(self):

        defString: str = (
            f'def __init__(self):{osLineSep}'
            f'    self._age:           int   = 3{osLineSep}'
            f'    self._publicEars:    float = 2{osLineSep}'
            f'    self._protectedTail: bool  = True{osLineSep}'
        )

        match: regExMatch | None = regExSearch(METHOD_FIND_PATTERN, defString)

        self.assertIsNotNone(match, 'We should find this')
        self.logger.debug(f'{match}')

    def testDecoratedMethodFindRegEx(self):
        defString: str = (
            '@abstractmethod'
            'def GetDiagram(self):'
            '   pass'
        )

        match: regExMatch | None = regExSearch(METHOD_FIND_PATTERN, defString)

        self.assertIsNotNone(match, 'We should find this')
        self.logger.debug(f'{match}')

    def testClassWithProperties(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('ClassWithProperties.py')
        visitor: PythonPegParserVisitor = PythonPegParserVisitor()

        visitor.modelClasses = self._do1stPassPegBasedParser('ClassWithProperties.py')
        visitor.visit(tree)

        className:  ModelClassName = ModelClassName('ClassWithProperties')
        modelClass: Class          = visitor.modelClasses[className]

        self.assertEqual(2, len(modelClass.fields), 'Not enough properties converted to fields')

    def testAssociationsGenerated(self):

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('AssociationClasses.py')
        visitor: PythonPegParserVisitor = PythonPegParserVisitor()

        visitor.modelClasses = self._do1stPassPegBasedParser('AssociationClasses.py')

        visitor.visit(tree)

        associations: Associations = visitor.associations

        self.assertEqual(2, len(associations), 'Incorrect number of associations generated')

    def testSimpleDataClass(self):

        fields: Fields = self._getSimpleDataClassFields()

        self.assertEqual(4, len(fields), 'Did not parse expected number of fields for this class')

    def testFullField(self):

        fields: Fields              = self._getSimpleDataClassFields()
        index:  ModelFieldHashIndex = self._makeFieldIndex(modelFields=fields)

        fullField: Field = index['y']

        self.assertIsNotNone(fullField, 'Where did it go?')
        self.assertEqual(FieldType('float'), fullField.type, 'Incorrect type')
        self.assertEqual('42.0', fullField.defaultValue, 'Incorrect default value')

    def testNoTypeField(self):
        fields: Fields              = self._getSimpleDataClassFields()
        index:  ModelFieldHashIndex = self._makeFieldIndex(modelFields=fields)

        noAssignmentField: Field = index['w']

        self.assertIsNotNone(noAssignmentField, 'Where did it go?')
        self.assertEqual(FieldType(''), noAssignmentField.type, 'Incorrect type')
        self.assertEqual('"A string"', noAssignmentField.defaultValue, 'Incorrect default value')

    def testNoDefaultValueField(self):
        fields: Fields              = self._getSimpleDataClassFields()
        index:  ModelFieldHashIndex = self._makeFieldIndex(modelFields=fields)

        noAssignmentField: Field = index['z']

        self.assertIsNotNone(noAssignmentField, 'Where did it go?')
        self.assertEqual(FieldType('int'), noAssignmentField.type, 'Incorrect type')
        self.assertEqual('', noAssignmentField.defaultValue, 'Should not have a value')

    def testExtractMethodCode(self):
        """
        This version of the parser returns the blank lines at the end of
        the methods
        """

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('SimpleClassWithCode.py')
        visitor: PythonPegParserVisitor = PythonPegParserVisitor()

        visitor.modelClasses = self._do1stPassPegBasedParser('SimpleClassWithCode.py')

        visitor.visit(tree)

        className:   ModelClassName = ModelClassName('SimpleClassWithCode')

        modelClasses: ModelClasses = visitor.modelClasses

        modelClass: Class   = modelClasses[className]
        methods:    Methods = modelClass.methods

        methodInit: Method = methods[0]
        self.assertEqual(7, len(methodInit.sourceCode), 'Mismatch of source code on __init__')

        methodPublicMethod: Method = methods[1]

        self.assertEqual(7, len(methodPublicMethod.sourceCode), 'Mismatch of source code on publicMethod')

    def _runVisibilityTest(self, methodName, visibility: Visibility):

        visitor: PythonPegParserVisitor = self._setupSimpleClassVisitor()

        className:    ModelClassName = ModelClassName('SimpleClass')
        modelClasses: ModelClasses   = visitor.modelClasses
        modelClass:   Class          = modelClasses[className]

        methodDict: MethodHashIndex = self._buildMethodHashIndex(methods=modelClass.methods)
        testMethod: Method          = methodDict[methodName]

        self.assertEqual(visibility, testMethod.visibility, 'Method visibility is incorrect')

    def _buildMethodHashIndex(self, methods: Methods) -> MethodHashIndex:

        methodDict: MethodHashIndex = MethodHashIndex({})
        for method in methods:
            methodDict[method.name] = method

        return methodDict

    def _getSimpleDataClassFields(self) -> Fields:

        visitor:     PythonPegParserVisitor = self._setupSimpleDataClassVisitor()
        modelClasses: ModelClasses          = visitor.modelClasses
        modelClass:   Class                 = modelClasses[SIMPLE_DATA_CLASS_NAME]

        return modelClass.fields

    def _setupSimpleClassVisitor(self) -> PythonPegParserVisitor:

        modelClasses: ModelClasses = self._do1stPassPegBasedParser('SimpleClass.py')

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('SimpleClass.py')
        visitor: PythonPegParserVisitor           = PythonPegParserVisitor()

        visitor.modelClasses = modelClasses

        visitor.visit(tree)

        return visitor

    def _setupSimpleDataClassVisitor(self) -> PythonPegParserVisitor:

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser('SimpleDataClass.py')
        visitor: PythonPegParserVisitor         = PythonPegParserVisitor()

        visitor.modelClasses = self._do1stPassPegBasedParser('SimpleDataClass.py')

        visitor.visit(tree)

        return visitor

    def _setupPegBasedParser(self, fileName: str) -> PythonParser.File_inputContext:

        fqFileName: str = UnitTestBase.getFullyQualifiedResourceFileName(BaseTestPythonPegVisitor.RESOURCES_TEST_CLASSES_PACKAGE_NAME, fileName)

        fileStream: FileStream  = FileStream(fqFileName)
        lexer:      PythonLexer = PythonLexer(fileStream)

        stream: CommonTokenStream = CommonTokenStream(lexer)
        parser: PythonParser      = PythonParser(stream)

        parser.removeParseListeners()
        parser.addErrorListener(PythonErrorListener())

        tree: PythonParser.File_inputContext = parser.file_input()
        if parser.getNumberOfSyntaxErrors() != 0:
            self.logger.error(f'File contains {parser.getNumberOfSyntaxErrors()} syntax errors')
            self.assertTrue(False, f'File contains {parser.getNumberOfSyntaxErrors()} syntax errors')

        return tree

    def _do1stPassPegBasedParser(self, fileName: str) -> ModelClasses:

        tree:    PythonParser.File_inputContext = self._setupPegBasedParser(fileName=fileName)
        visitor: PythonPegParserClassVisitor    = PythonPegParserClassVisitor()

        visitor.visit(tree)

        return visitor.modelClasses


def suite() -> TestSuite:
    import unittest

    testSuite: TestSuite = TestSuite()

    testSuite.addTest(unittest.defaultTestLoader.loadTestsFromTestCase(testCaseClass=TestPythonPegParserVisitor))

    return testSuite


if __name__ == '__main__':
    unitTestMain()
